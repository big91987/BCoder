# æŠ€æœ¯æ¶æ„è®¾è®¡

## ğŸ—ï¸ æ•´ä½“æ¶æ„

### ç³»ç»Ÿæ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    BCoder VSCode Extension                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  UI Layer                                                   â”‚
â”‚  â”œâ”€â”€ Chat Interface (Webview)                              â”‚
â”‚  â”œâ”€â”€ Settings Panel                                        â”‚
â”‚  â””â”€â”€ Status Indicators                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Agent Layer                                               â”‚
â”‚  â”œâ”€â”€ Task Planner                                          â”‚
â”‚  â”œâ”€â”€ Tool Orchestrator                                     â”‚
â”‚  â””â”€â”€ Context Manager                                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Tool Layer                                                â”‚
â”‚  â”œâ”€â”€ File Operations    â”œâ”€â”€ Code Analysis                  â”‚
â”‚  â”œâ”€â”€ Terminal Control   â”œâ”€â”€ Git Integration                â”‚
â”‚  â””â”€â”€ VSCode Integration â””â”€â”€ Web Search                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Retrieval Layer                                           â”‚
â”‚  â”œâ”€â”€ Hybrid Search Engine                                  â”‚
â”‚  â”œâ”€â”€ AST Parser                                            â”‚
â”‚  â””â”€â”€ Semantic Indexer                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  External Integrations                                     â”‚
â”‚  â”œâ”€â”€ MCP Servers        â”œâ”€â”€ Language Servers               â”‚
â”‚  â”œâ”€â”€ LLM APIs          â””â”€â”€ Local Models                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ§  Agent å·¥ä½œæµç¨‹

### æ ¸å¿ƒ Agent Loop

åŸºäºå¯¹ Cline å’Œ Augment SWE-bench Agent çš„åˆ†æï¼Œè®¾è®¡å¦‚ä¸‹å·¥ä½œæµç¨‹ï¼š

```typescript
class BCoderAgent {
  async processTask(userInput: string): Promise<void> {
    while (!this.isTaskComplete()) {
      // 1. è§‚å¯Ÿ (Observe)
      const context = await this.observe();
      
      // 2. è®¡åˆ’ (Plan) 
      const plan = await this.plan(context, userInput);
      
      // 3. æ‰§è¡Œ (Act)
      const results = await this.act(plan);
      
      // 4. åæ€ (Reflect)
      const reflection = await this.reflect(results);
      
      if (reflection.shouldContinue) {
        this.updateContext(reflection);
      } else {
        break;
      }
    }
  }
}
```

### å·¥ä½œæµç¨‹è¯¦è§£

#### Phase 1: è§‚å¯Ÿ (Observe)
```typescript
async observe(): Promise<Context> {
  return {
    // å½“å‰å·¥ä½œåŒºçŠ¶æ€
    workspace: await this.scanWorkspace(),
    
    // æ´»åŠ¨æ–‡ä»¶ä¿¡æ¯
    activeFile: await this.getActiveFileInfo(),
    
    // Git çŠ¶æ€
    gitStatus: await this.getGitStatus(),
    
    // ç»ˆç«¯çŠ¶æ€
    terminalState: await this.getTerminalState(),
    
    // é”™è¯¯å’Œé—®é¢˜
    diagnostics: await this.getDiagnostics()
  };
}
```

#### Phase 2: è®¡åˆ’ (Plan)
```typescript
async plan(context: Context, task: string): Promise<Plan> {
  // 1. ä»»åŠ¡åˆ†è§£
  const subtasks = await this.decomposeTask(task);
  
  // 2. å·¥å…·é€‰æ‹©
  const tools = await this.selectTools(subtasks);
  
  // 3. æ‰§è¡Œé¡ºåº
  const sequence = await this.planSequence(subtasks, tools);
  
  return { subtasks, tools, sequence };
}
```

#### Phase 3: æ‰§è¡Œ (Act)
```typescript
async act(plan: Plan): Promise<ActionResult[]> {
  const results = [];
  
  for (const step of plan.sequence) {
    try {
      const result = await this.executeStep(step);
      results.push(result);
      
      // å®æ—¶åé¦ˆ
      await this.provideFeedback(step, result);
      
    } catch (error) {
      await this.handleError(error, step);
    }
  }
  
  return results;
}
```

## ğŸ” æ··åˆæ£€ç´¢ç³»ç»Ÿ

### å¤šå±‚æ¬¡æ£€ç´¢æ¶æ„

åŸºäºå¯¹ç°æœ‰å·¥å…·æ£€ç´¢èƒ½åŠ›çš„åˆ†æï¼Œè®¾è®¡ä¸‰å±‚æ£€ç´¢ç³»ç»Ÿï¼š

```typescript
class HybridRetrievalEngine {
  // ç¬¬ä¸€å±‚ï¼šå¿«é€Ÿæ–‡æœ¬æœç´¢
  async textSearch(query: string): Promise<TextResult[]> {
    return await this.ripgrepSearch(query);
  }
  
  // ç¬¬äºŒå±‚ï¼šAST ç»“æ„æœç´¢  
  async astSearch(query: string): Promise<ASTResult[]> {
    return await this.treeSitterSearch(query);
  }
  
  // ç¬¬ä¸‰å±‚ï¼šè¯­ä¹‰å‘é‡æœç´¢
  async semanticSearch(query: string): Promise<SemanticResult[]> {
    return await this.embeddingSearch(query);
  }
  
  // èåˆæ’åº
  async hybridSearch(query: string): Promise<SearchResult[]> {
    const [textResults, astResults, semanticResults] = await Promise.all([
      this.textSearch(query),
      this.astSearch(query), 
      this.semanticSearch(query)
    ]);
    
    return this.fusionRanking([textResults, astResults, semanticResults]);
  }
}
```

### æ£€ç´¢ç­–ç•¥å¯¹æ¯”

| æ£€ç´¢æ–¹æ³• | é€Ÿåº¦ | å‡†ç¡®æ€§ | é€‚ç”¨åœºæ™¯ | BCoder ä½¿ç”¨ |
|---------|------|--------|---------|------------|
| **æ–‡æœ¬æœç´¢** | âš¡âš¡âš¡ | â­â­ | å…³é”®è¯æŸ¥æ‰¾ | ç¬¬ä¸€å±‚è¿‡æ»¤ |
| **AST æœç´¢** | âš¡âš¡ | â­â­â­â­ | è¯­æ³•ç»“æ„ | ç²¾ç¡®åŒ¹é… |
| **è¯­ä¹‰æœç´¢** | âš¡ | â­â­â­â­â­ | æ¦‚å¿µç†è§£ | æ™ºèƒ½å…³è” |

## ğŸ› ï¸ å·¥å…·ç³»ç»Ÿè®¾è®¡

### æ ¸å¿ƒå·¥å…·é›†

åŸºäºå¯¹ Cline å’Œ MCP æ ‡å‡†çš„åˆ†æï¼Œè®¾è®¡å¦‚ä¸‹å·¥å…·ä½“ç³»ï¼š

#### æ–‡ä»¶æ“ä½œå·¥å…·
```typescript
interface FileTools {
  read_file(path: string): Promise<string>;
  write_file(path: string, content: string): Promise<void>;
  edit_file(path: string, changes: EditChange[]): Promise<void>;
  list_files(directory: string): Promise<FileInfo[]>;
  search_files(pattern: string): Promise<SearchResult[]>;
}
```

#### ä»£ç åˆ†æå·¥å…·
```typescript
interface CodeAnalysisTools {
  parse_ast(file: string): Promise<ASTNode>;
  find_definitions(symbol: string): Promise<Definition[]>;
  find_references(symbol: string): Promise<Reference[]>;
  get_diagnostics(file: string): Promise<Diagnostic[]>;
}
```

#### ç»ˆç«¯æ§åˆ¶å·¥å…·
```typescript
interface TerminalTools {
  execute_command(command: string): Promise<CommandResult>;
  start_process(command: string): Promise<ProcessHandle>;
  get_process_output(handle: ProcessHandle): Promise<string>;
  kill_process(handle: ProcessHandle): Promise<void>;
}
```

#### VSCode é›†æˆå·¥å…·
```typescript
interface VSCodeTools {
  open_file(path: string): Promise<void>;
  show_diff(original: string, modified: string): Promise<void>;
  insert_text(position: Position, text: string): Promise<void>;
  show_notification(message: string): Promise<void>;
}
```

### å·¥å…·é€‰æ‹©ç­–ç•¥

```typescript
class ToolSelector {
  selectTools(task: TaskType): Tool[] {
    switch (task) {
      case 'bug_fix':
        return ['read_file', 'search_files', 'edit_file', 'execute_command'];
      case 'feature_implementation':
        return ['list_files', 'read_file', 'write_file', 'execute_command'];
      case 'code_review':
        return ['read_file', 'get_diagnostics', 'find_references'];
      case 'refactoring':
        return ['parse_ast', 'find_references', 'edit_file'];
    }
  }
}
```

## ğŸ”— MCP é›†æˆæ¶æ„

### MCP æœåŠ¡å™¨é›†æˆ

åŸºäºè°ƒç ”çš„ MCP æ ‡å‡†æœåŠ¡å™¨ï¼Œè®¾è®¡å¦‚ä¸‹é›†æˆæ–¹æ¡ˆï¼š

```typescript
class MCPIntegration {
  private servers = new Map<string, MCPServer>();
  
  async initializeServers() {
    // æ–‡ä»¶ç³»ç»ŸæœåŠ¡å™¨
    this.servers.set('filesystem', new MCPServer({
      command: 'npx',
      args: ['-y', '@modelcontextprotocol/server-filesystem', this.workspaceRoot]
    }));
    
    // Git æœåŠ¡å™¨
    this.servers.set('git', new MCPServer({
      command: 'npx', 
      args: ['-y', '@modelcontextprotocol/server-git']
    }));
    
    // æœç´¢æœåŠ¡å™¨
    this.servers.set('search', new MCPServer({
      command: 'npx',
      args: ['-y', '@modelcontextprotocol/server-brave-search']
    }));
  }
  
  async callTool(serverName: string, toolName: string, args: any) {
    const server = this.servers.get(serverName);
    return await server.callTool(toolName, args);
  }
}
```

### æœ¬åœ° vs MCP å·¥å…·ç­–ç•¥

```typescript
class ToolRouter {
  async routeToolCall(toolName: string, args: any) {
    // æ£€æµ‹ç¯å¢ƒ
    if (this.isRemoteEnvironment()) {
      // SSH Remote: ä½¿ç”¨ VSCode API
      return await this.vscodeTools[toolName](args);
    } else {
      // æœ¬åœ°ç¯å¢ƒ: ä¼˜å…ˆä½¿ç”¨ MCP
      return await this.mcpTools[toolName](args);
    }
  }
  
  private isRemoteEnvironment(): boolean {
    return vscode.env.remoteName !== undefined;
  }
}
```

## ğŸ¯ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### ä¸Šä¸‹æ–‡ç®¡ç†

```typescript
class ContextManager {
  private maxTokens = 100000;
  
  async optimizeContext(files: FileInfo[]): Promise<OptimizedContext> {
    // 1. é‡è¦æ€§è¯„åˆ†
    const scored = files.map(file => ({
      ...file,
      importance: this.calculateImportance(file),
      tokens: this.estimateTokens(file)
    }));
    
    // 2. è´ªå¿ƒé€‰æ‹©
    const selected = this.greedySelection(scored, this.maxTokens);
    
    // 3. å†…å®¹å‹ç¼©
    const compressed = await this.compressContent(selected);
    
    return compressed;
  }
}
```

### å¢é‡ç´¢å¼•

```typescript
class IncrementalIndexer {
  async onFileChange(filePath: string) {
    // 1. è§£æå˜æ›´æ–‡ä»¶
    const ast = await this.parseAST(filePath);
    
    // 2. æ›´æ–°ç´¢å¼•
    await this.updateIndex(filePath, ast);
    
    // 3. æ›´æ–°ä¾èµ–å…³ç³»
    await this.updateDependencies(filePath);
  }
}
```

## ğŸ”’ å®‰å…¨æ¶æ„

### æƒé™æ§åˆ¶

```typescript
class SecurityManager {
  async validateOperation(operation: Operation): Promise<boolean> {
    // 1. è·¯å¾„éªŒè¯
    if (!this.isPathSafe(operation.path)) {
      return false;
    }
    
    // 2. å‘½ä»¤ç™½åå•
    if (!this.isCommandSafe(operation.command)) {
      return false;
    }
    
    // 3. ç”¨æˆ·ç¡®è®¤
    if (operation.requiresConfirmation) {
      return await this.requestUserConfirmation(operation);
    }
    
    return true;
  }
}
```

### æ²™ç®±æ‰§è¡Œ

```typescript
class SandboxExecutor {
  async executeCommand(command: string): Promise<CommandResult> {
    // 1. å‘½ä»¤éªŒè¯
    await this.validateCommand(command);
    
    // 2. æ²™ç®±ç¯å¢ƒ
    const sandbox = await this.createSandbox();
    
    // 3. æ‰§è¡Œç›‘æ§
    return await this.monitoredExecution(sandbox, command);
  }
}
```

---

*ä¸‹ä¸€æ­¥: æŸ¥çœ‹ [äº§å“åŠŸèƒ½éœ€æ±‚](./03-product-requirements.md)*
