# æŠ€æœ¯æ¶æ„è®¾è®¡

## ğŸ—ï¸ æ•´ä½“æ¶æ„

### ç³»ç»Ÿæ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    BCoder VSCode Extension                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  UI Layer                                                   â”‚
â”‚  â”œâ”€â”€ Chat Interface (Webview)                              â”‚
â”‚  â”œâ”€â”€ Settings Panel                                        â”‚
â”‚  â”œâ”€â”€ Cost Display (å®æ—¶æˆæœ¬è¿½è¸ª)                            â”‚
â”‚  â””â”€â”€ Status Indicators                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Agent Layer                                               â”‚
â”‚  â”œâ”€â”€ Task Planner                                          â”‚
â”‚  â”œâ”€â”€ Tool Orchestrator                                     â”‚
â”‚  â””â”€â”€ Context Manager                                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Tool Layer                                                â”‚
â”‚  â”œâ”€â”€ File Operations    â”œâ”€â”€ Code Analysis                  â”‚
â”‚  â”œâ”€â”€ Terminal Control   â”œâ”€â”€ Git Integration                â”‚
â”‚  â””â”€â”€ VSCode Integration â””â”€â”€ Web Search                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Retrieval Layer                                           â”‚
â”‚  â”œâ”€â”€ Hybrid Search Engine                                  â”‚
â”‚  â”œâ”€â”€ AST Parser                                            â”‚
â”‚  â””â”€â”€ Semantic Indexer                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  External Integrations                                     â”‚
â”‚  â”œâ”€â”€ MCP Servers        â”œâ”€â”€ Language Servers               â”‚
â”‚  â”œâ”€â”€ LLM APIs          â””â”€â”€ Local Models                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ§  Agent å·¥ä½œæµç¨‹

### æ ¸å¿ƒ Agent Loop

åŸºäºå¯¹ Cline å’Œ Augment SWE-bench Agent çš„åˆ†æï¼Œè®¾è®¡å¦‚ä¸‹å·¥ä½œæµç¨‹ï¼š

```typescript
class BCoderAgent {
  async processTask(userInput: string): Promise<void> {
    while (!this.isTaskComplete()) {
      // 1. è§‚å¯Ÿ (Observe)
      const context = await this.observe();

      // 2. è®¡åˆ’ (Plan)
      const plan = await this.plan(context, userInput);

      // 3. æ‰§è¡Œ (Act)
      const results = await this.act(plan);

      // 4. åæ€ (Reflect)
      const reflection = await this.reflect(results);

      if (reflection.shouldContinue) {
        this.updateContext(reflection);
      } else {
        break;
      }
    }
  }
}
```

### å·¥ä½œæµç¨‹è¯¦è§£

#### Phase 1: è§‚å¯Ÿ (Observe)
```typescript
async observe(): Promise<Context> {
  return {
    // å½“å‰å·¥ä½œåŒºçŠ¶æ€
    workspace: await this.scanWorkspace(),

    // æ´»åŠ¨æ–‡ä»¶ä¿¡æ¯
    activeFile: await this.getActiveFileInfo(),

    // Git çŠ¶æ€
    gitStatus: await this.getGitStatus(),

    // ç»ˆç«¯çŠ¶æ€
    terminalState: await this.getTerminalState(),

    // é”™è¯¯å’Œé—®é¢˜
    diagnostics: await this.getDiagnostics()
  };
}
```

#### Phase 2: è®¡åˆ’ (Plan)
```typescript
async plan(context: Context, task: string): Promise<Plan> {
  // 1. ä»»åŠ¡åˆ†è§£
  const subtasks = await this.decomposeTask(task);

  // 2. å·¥å…·é€‰æ‹©
  const tools = await this.selectTools(subtasks);

  // 3. æ‰§è¡Œé¡ºåº
  const sequence = await this.planSequence(subtasks, tools);

  return { subtasks, tools, sequence };
}
```

#### Phase 3: æ‰§è¡Œ (Act)
```typescript
async act(plan: Plan): Promise<ActionResult[]> {
  const results = [];

  for (const step of plan.sequence) {
    try {
      const result = await this.executeStep(step);
      results.push(result);

      // å®æ—¶åé¦ˆ
      await this.provideFeedback(step, result);

    } catch (error) {
      await this.handleError(error, step);
    }
  }

  return results;
}
```

## ğŸ” æ··åˆæ£€ç´¢ç³»ç»Ÿ

### å¤šå±‚æ¬¡æ£€ç´¢æ¶æ„

åŸºäºå¯¹ç°æœ‰å·¥å…·æ£€ç´¢èƒ½åŠ›çš„åˆ†æï¼Œè®¾è®¡ä¸‰å±‚æ£€ç´¢ç³»ç»Ÿï¼š

```typescript
class HybridRetrievalEngine {
  // ç¬¬ä¸€å±‚ï¼šå¿«é€Ÿæ–‡æœ¬æœç´¢
  async textSearch(query: string): Promise<TextResult[]> {
    return await this.ripgrepSearch(query);
  }

  // ç¬¬äºŒå±‚ï¼šAST ç»“æ„æœç´¢
  async astSearch(query: string): Promise<ASTResult[]> {
    return await this.treeSitterSearch(query);
  }

  // ç¬¬ä¸‰å±‚ï¼šè¯­ä¹‰å‘é‡æœç´¢
  async semanticSearch(query: string): Promise<SemanticResult[]> {
    return await this.embeddingSearch(query);
  }

  // èåˆæ’åº
  async hybridSearch(query: string): Promise<SearchResult[]> {
    const [textResults, astResults, semanticResults] = await Promise.all([
      this.textSearch(query),
      this.astSearch(query),
      this.semanticSearch(query)
    ]);

    return this.fusionRanking([textResults, astResults, semanticResults]);
  }
}
```

### æ£€ç´¢ç­–ç•¥å¯¹æ¯”

| æ£€ç´¢æ–¹æ³• | é€Ÿåº¦ | å‡†ç¡®æ€§ | é€‚ç”¨åœºæ™¯ | BCoder ä½¿ç”¨ |
|---------|------|--------|---------|------------|
| **æ–‡æœ¬æœç´¢** | âš¡âš¡âš¡ | â­â­ | å…³é”®è¯æŸ¥æ‰¾ | ç¬¬ä¸€å±‚è¿‡æ»¤ |
| **AST æœç´¢** | âš¡âš¡ | â­â­â­â­ | è¯­æ³•ç»“æ„ | ç²¾ç¡®åŒ¹é… |
| **è¯­ä¹‰æœç´¢** | âš¡ | â­â­â­â­â­ | æ¦‚å¿µç†è§£ | æ™ºèƒ½å…³è” |

## ğŸ› ï¸ å·¥å…·ç³»ç»Ÿè®¾è®¡

### æ ¸å¿ƒå·¥å…·é›†

åŸºäºå¯¹ Cline å’Œ MCP æ ‡å‡†çš„åˆ†æï¼Œè®¾è®¡å¦‚ä¸‹å·¥å…·ä½“ç³»ï¼š

#### æ–‡ä»¶æ“ä½œå·¥å…·
```typescript
interface FileTools {
  read_file(path: string): Promise<string>;
  write_file(path: string, content: string): Promise<void>;
  edit_file(path: string, changes: EditChange[]): Promise<void>;
  list_files(directory: string): Promise<FileInfo[]>;
  search_files(pattern: string): Promise<SearchResult[]>;
}
```

#### ä»£ç åˆ†æå·¥å…·
```typescript
interface CodeAnalysisTools {
  parse_ast(file: string): Promise<ASTNode>;
  find_definitions(symbol: string): Promise<Definition[]>;
  find_references(symbol: string): Promise<Reference[]>;
  get_diagnostics(file: string): Promise<Diagnostic[]>;
}
```

#### ç»ˆç«¯æ§åˆ¶å·¥å…·
```typescript
interface TerminalTools {
  execute_command(command: string): Promise<CommandResult>;
  start_process(command: string): Promise<ProcessHandle>;
  get_process_output(handle: ProcessHandle): Promise<string>;
  kill_process(handle: ProcessHandle): Promise<void>;
}
```

#### VSCode é›†æˆå·¥å…·
```typescript
interface VSCodeTools {
  open_file(path: string): Promise<void>;
  show_diff(original: string, modified: string): Promise<void>;
  insert_text(position: Position, text: string): Promise<void>;
  show_notification(message: string): Promise<void>;
}
```

### å·¥å…·é€‰æ‹©ç­–ç•¥

```typescript
class ToolSelector {
  selectTools(task: TaskType): Tool[] {
    switch (task) {
      case 'bug_fix':
        return ['read_file', 'search_files', 'edit_file', 'execute_command'];
      case 'feature_implementation':
        return ['list_files', 'read_file', 'write_file', 'execute_command'];
      case 'code_review':
        return ['read_file', 'get_diagnostics', 'find_references'];
      case 'refactoring':
        return ['parse_ast', 'find_references', 'edit_file'];
    }
  }
}
```

## ğŸ”— MCP é›†æˆæ¶æ„

### MCP æœåŠ¡å™¨é›†æˆ

åŸºäºè°ƒç ”çš„ MCP æ ‡å‡†æœåŠ¡å™¨ï¼Œè®¾è®¡å¦‚ä¸‹é›†æˆæ–¹æ¡ˆï¼š

```typescript
class MCPIntegration {
  private servers = new Map<string, MCPServer>();

  async initializeServers() {
    // æ–‡ä»¶ç³»ç»ŸæœåŠ¡å™¨
    this.servers.set('filesystem', new MCPServer({
      command: 'npx',
      args: ['-y', '@modelcontextprotocol/server-filesystem', this.workspaceRoot]
    }));

    // Git æœåŠ¡å™¨
    this.servers.set('git', new MCPServer({
      command: 'npx',
      args: ['-y', '@modelcontextprotocol/server-git']
    }));

    // æœç´¢æœåŠ¡å™¨
    this.servers.set('search', new MCPServer({
      command: 'npx',
      args: ['-y', '@modelcontextprotocol/server-brave-search']
    }));
  }

  async callTool(serverName: string, toolName: string, args: any) {
    const server = this.servers.get(serverName);
    return await server.callTool(toolName, args);
  }
}
```

### æœ¬åœ° vs MCP å·¥å…·ç­–ç•¥

```typescript
class ToolRouter {
  async routeToolCall(toolName: string, args: any) {
    // æ£€æµ‹ç¯å¢ƒ
    if (this.isRemoteEnvironment()) {
      // SSH Remote: ä½¿ç”¨ VSCode API
      return await this.vscodeTools[toolName](args);
    } else {
      // æœ¬åœ°ç¯å¢ƒ: ä¼˜å…ˆä½¿ç”¨ MCP
      return await this.mcpTools[toolName](args);
    }
  }

  private isRemoteEnvironment(): boolean {
    return vscode.env.remoteName !== undefined;
  }
}
```

## ğŸ¯ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### ä¸Šä¸‹æ–‡ç®¡ç†

```typescript
class ContextManager {
  private maxTokens = 100000;

  async optimizeContext(files: FileInfo[]): Promise<OptimizedContext> {
    // 1. é‡è¦æ€§è¯„åˆ†
    const scored = files.map(file => ({
      ...file,
      importance: this.calculateImportance(file),
      tokens: this.estimateTokens(file)
    }));

    // 2. è´ªå¿ƒé€‰æ‹©
    const selected = this.greedySelection(scored, this.maxTokens);

    // 3. å†…å®¹å‹ç¼©
    const compressed = await this.compressContent(selected);

    return compressed;
  }
}
```

### å¢é‡ç´¢å¼•

```typescript
class IncrementalIndexer {
  async onFileChange(filePath: string) {
    // 1. è§£æå˜æ›´æ–‡ä»¶
    const ast = await this.parseAST(filePath);

    // 2. æ›´æ–°ç´¢å¼•
    await this.updateIndex(filePath, ast);

    // 3. æ›´æ–°ä¾èµ–å…³ç³»
    await this.updateDependencies(filePath);
  }
}
```

## ğŸ”’ å®‰å…¨æ¶æ„

### Auto-approve æƒé™ç³»ç»Ÿ (å€Ÿé‰´ Cline)

```typescript
interface AutoApproveSettings {
  enabled: boolean;
  filePermissions: {
    readProjectFiles: boolean;
    readAllFiles: boolean;
    editProjectFiles: boolean;
  };
  commandPermissions: {
    executeSafeCommands: boolean;
    executeAllCommands: boolean;
    customWhitelist: string[];
  };
  externalPermissions: {
    useBrowser: boolean;
    useMCPServers: boolean;
    useWebSearch: boolean;
  };
  quickSettings: {
    enableNotifications: boolean;
    maxRequests: number;
  };
}

class PermissionManager {
  async checkPermission(action: Action): Promise<boolean> {
    const settings = await this.getAutoApproveSettings();

    if (!settings.enabled) {
      return await this.requestUserApproval(action);
    }

    switch (action.type) {
      case 'read_file':
        return this.checkFileReadPermission(action, settings);
      case 'edit_file':
        return this.checkFileEditPermission(action, settings);
      case 'execute_command':
        return this.checkCommandPermission(action, settings);
      default:
        return await this.requestUserApproval(action);
    }
  }

  private isSafeCommand(command: string): boolean {
    const safeCommands = [
      'ls', 'cat', 'head', 'tail', 'grep', 'find',
      'git status', 'git log', 'git diff',
      'npm test', 'npm run build'
    ];
    return safeCommands.some(safe => command.startsWith(safe));
  }
}
```

### ä¼ ç»Ÿæƒé™æ§åˆ¶

```typescript
class SecurityManager {
  async validateOperation(operation: Operation): Promise<boolean> {
    // 1. Auto-approve æ£€æŸ¥
    const autoApproved = await this.permissionManager.checkPermission(operation);
    if (autoApproved) {
      return true;
    }

    // 2. è·¯å¾„éªŒè¯
    if (!this.isPathSafe(operation.path)) {
      return false;
    }

    // 3. å‘½ä»¤ç™½åå•
    if (!this.isCommandSafe(operation.command)) {
      return false;
    }

    // 4. ç”¨æˆ·ç¡®è®¤
    return await this.requestUserConfirmation(operation);
  }
}
```

### æ²™ç®±æ‰§è¡Œ

```typescript
class SandboxExecutor {
  async executeCommand(command: string): Promise<CommandResult> {
    // 1. å‘½ä»¤éªŒè¯
    await this.validateCommand(command);

    // 2. æ²™ç®±ç¯å¢ƒ
    const sandbox = await this.createSandbox();

    // 3. æ‰§è¡Œç›‘æ§
    return await this.monitoredExecution(sandbox, command);
  }
}
```

## ğŸ’° æˆæœ¬è¿½è¸ªå’Œç¼“å­˜ç³»ç»Ÿ

### æˆæœ¬è¿½è¸ªæ¶æ„

```typescript
interface CostMetrics {
  totalCost: number;
  inputTokens: number;
  outputTokens: number;
  cachedTokens: number;
  contextUsage: { current: number; max: number };
  storageSize: number;
}

class CostTracker {
  private metrics: CostMetrics = {
    totalCost: 0,
    inputTokens: 0,
    outputTokens: 0,
    cachedTokens: 0,
    contextUsage: { current: 0, max: 200000 },
    storageSize: 0
  };

  async trackAPICall(request: APIRequest, response: APIResponse): Promise<void> {
    // 1. æå–ä½¿ç”¨ç»Ÿè®¡
    const usage = response.usage;
    this.metrics.inputTokens += usage.prompt_tokens;
    this.metrics.outputTokens += usage.completion_tokens;
    this.metrics.cachedTokens += usage.prompt_tokens_details?.cached_tokens || 0;

    // 2. è®¡ç®—æˆæœ¬
    const cost = this.calculateCost(usage, request.model);
    this.metrics.totalCost += cost;

    // 3. æ›´æ–°ä¸Šä¸‹æ–‡ä½¿ç”¨
    this.metrics.contextUsage.current = usage.prompt_tokens;

    // 4. æ›´æ–° UI
    this.updateCostDisplay();

    // 5. æˆæœ¬é¢„è­¦
    this.checkCostThresholds();
  }

  private calculateCost(usage: TokenUsage, model: string): number {
    const pricing = this.getModelPricing(model);

    // è®¡ç®—ç¼“å­˜èŠ‚çœ
    const regularTokens = usage.prompt_tokens - (usage.prompt_tokens_details?.cached_tokens || 0);
    const cachedTokens = usage.prompt_tokens_details?.cached_tokens || 0;

    const inputCost = (regularTokens * pricing.input) + (cachedTokens * pricing.cached_input);
    const outputCost = usage.completion_tokens * pricing.output;

    return inputCost + outputCost;
  }
}
```

### Prompt Caching ä¼˜åŒ–

```typescript
class CacheOptimizer {
  buildCachedRequest(messages: Message[], context: ProjectContext): APIRequest {
    return {
      model: this.selectedModel,
      messages: [
        // ç³»ç»Ÿæç¤ºè¯ - é•¿æœŸç¼“å­˜
        {
          role: "system",
          content: [{
            type: "text",
            text: this.buildSystemPrompt(),
            cache_control: { type: "ephemeral" }
          }]
        },

        // å·¥å…·å®šä¹‰ - ä¸­æœŸç¼“å­˜
        {
          role: "user",
          content: [{
            type: "text",
            text: this.buildToolDefinitions(),
            cache_control: { type: "ephemeral" }
          }]
        },

        // é¡¹ç›®ä¸Šä¸‹æ–‡ - çŸ­æœŸç¼“å­˜
        {
          role: "user",
          content: [{
            type: "text",
            text: this.buildProjectContext(context),
            cache_control: { type: "ephemeral" }
          }]
        },

        // ç”¨æˆ·æ¶ˆæ¯ - ä¸ç¼“å­˜
        ...messages
      ]
    };
  }

  private getCacheStrategy(contentType: string): CacheControl | null {
    const strategies = {
      'system_prompt': { type: 'ephemeral', priority: 'high' },
      'tool_definitions': { type: 'ephemeral', priority: 'medium' },
      'project_context': { type: 'ephemeral', priority: 'low' },
      'user_messages': null // ä¸ç¼“å­˜
    };

    return strategies[contentType] || null;
  }
}
```

### å¤šæ¨¡å‹æˆæœ¬ç®¡ç†

```typescript
class ModelPricingManager {
  private pricingTable = {
    'claude-3-5-sonnet-20241022': {
      input: 0.003,        // æ¯ 1K tokens
      output: 0.015,       // æ¯ 1K tokens
      cached_input: 0.0003 // ç¼“å­˜å‘½ä¸­æˆæœ¬ (10%)
    },
    'gpt-4o': {
      input: 0.0025,
      output: 0.01,
      cached_input: 0.00125 // ç¼“å­˜å‘½ä¸­æˆæœ¬ (50%)
    },
    'doubao-1-5-vision-pro-32k': {
      input: 0.0008,       // ç«å±±æ–¹èˆŸå®šä»·
      output: 0.002,
      cached_input: 0.0001 // ä¼°ç®—ç¼“å­˜æˆæœ¬
    }
  };

  getCostComparison(usage: TokenUsage): ModelCostComparison[] {
    return Object.entries(this.pricingTable).map(([model, pricing]) => ({
      model,
      cost: this.calculateModelCost(usage, pricing),
      savings: this.calculateCacheSavings(usage, pricing)
    }));
  }
}
```



---

*ä¸‹ä¸€æ­¥: æŸ¥çœ‹ [äº§å“åŠŸèƒ½éœ€æ±‚](./03-product-requirements.md)*
